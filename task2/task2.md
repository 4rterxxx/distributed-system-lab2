# Задание 2: Моделирование задачи N тел

## 1. Постановка задачи

**Цель:** Реализовать параллельную программу для моделирования гравитационного взаимодействия N материальных точек (задача N тел) с использованием метода Эйлера первого порядка и технологии OpenMP.

**Физическая модель:** Система из N частиц взаимодействует по закону всемирного тяготения Ньютона. Сила, действующая на частицу i со стороны частицы j:
F_ij = G * (m_i * m_j) / (r_ij³) * (r_j - r_i)
где G = 6.67430e-11 — гравитационная постоянная, r_ij — расстояние между частицами.

**Численный метод:** Метод Эйлера первого порядка с шагом Δt = 3600 секунд (1 час):
v_i_new = v_i_old + a_i * Δt
r_i_new = r_i_old + v_i_old * Δt
где a_i = сумма всех сил, действующих на частицу i, деленная на ее массу.

**Аппаратная архитектура:**
- Процессор: 4 процессора × 2 ядра = 8 физических ядер
- Операционная система: Debian Linux
- Компилятор: gcc с поддержкой OpenMP

**Методика измерений:**
- Время измерялось однократно для каждого запуска (не усреднялось)
- Измерялось полное время выполнения программы от начала до конца
- Использовалась функция `omp_get_wtime()` для точного замера
- Для каждого сочетания (число потоков × число частиц) проводился отдельный запуск
- Шаг по времени Δt = 3600 секунд (фиксированный)

## 2. Реализация алгоритма

### Структура данных
```c
typedef struct {
    double mass, x, y, z, vx, vy, vz, ax, ay, az;
} Particle;
```

### Основные этапы алгоритма:
1. Чтение входных данных: массы, начальные координаты и скорости частиц
2. Вычисление ускорений: O(N²) операций, распараллеливается по внешнему циклу
3. Интегрирование уравнений движения: обновление скоростей и координат
4. Запись траекторий: вывод в CSV-формат


### Параллельная реализация на OpenMP

#### Ключевые директивы OpenMP

**1. Установка числа потоков:**
```c
omp_set_num_threads(num_threads);
```

**2. Распараллеливание вычисления ускорений:**
```c
#pragma omp parallel for
for (int i = 0; i < n; i++) {
    // вычисление суммарного ускорения для частицы i
    // от всех остальных частиц j
}
```

**3. Распараллеливание обновления состояний:**
```c
#pragma omp parallel for
for (int i = 0; i < n; i++) {
    // обновление скорости и координат частицы i
}
```

### Особенности реализации
- Разделение вычислений: два независимых параллельных цикла (ускорения и обновление)
- Избегание гонок данных: каждый поток вычисляет ускорения для своего набора частиц
- Локальность данных: структура Particle хранит все параметры частицы вместе

## 3. Результаты экспериментов

### Время выполнения (секунды)

| Количество частиц | 1 поток | 2 потока | 4 потока | 8 потоков |
|------------------|---------|----------|----------|-----------|
| 50               | 0.000495| 0.000436 | 0.000591 | 0.000998  |
| 500              | 0.009446| 0.006661 | 0.005808 | 0.005655  |
| 5000             | 0.755863| 0.409038 | 0.229413 | 0.202311  |



## 4. Анализ результатов

### Масштабируемость
- Для 50 частиц: параллелизация неэффективна из-за малого объема вычислений
- Для 500 частиц: умеренное ускорение, эффективность снижается с ростом числа потоков
- Для 5000 частиц: хорошее масштабирование, эффективность до 82% при 4 потоках

### Оптимальная конфигурация
- 50 частиц: 1-2 потока
- 500 частиц: 2-4 потока
- 5000 частиц: 4-8 потоков


### Анализ накладных расходов

Основные источники накладных расходов:
1. Создание и уничтожение потоков (особенно заметно для малых задач)
2. Синхронизация между циклами (неявный барьер после `parallel for`)
3. Конкуренция за доступ к памяти (особенно при 8 потоках)

## 5. Выводы

Программа успешно моделирует гравитационное взаимодействие N тел с использованием метода Эйлера. Параллельная реализация демонстрирует хорошую масштабируемость для больших систем (5000 частиц), достигая ускорения 3.74x при использовании 8 потоков. Однако для малых систем накладные расходы на управление потоками превышают вычислительную выгоду.

Ключевые факторы эффективности:
1. Размер задачи определяет оптимальное число потоков
2. Вычисления ускорений хорошо распараллеливаются благодаря независимости частиц
3. Метод Эйлера обеспечивает простоту реализации, но имеет низкую точность
